<!DOCTYPE html><html lang="en-gb"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1"><title>Understanding GraphQL Scalars and Enums - GraphQL</title><meta name="description" content="GraphQL is a powerful query language for APIs that allows clients to request exactly the data they need. One of its core features is its type system, which ensures that both the client and server have a clear understanding of the structure and shape of&hellip;"><meta name="generator" content="Publii Open-Source CMS for Static Site"><link rel="canonical" href="https://aymengn.github.io/graphql/understanding-graphql-scalars-and-enums.html"><link rel="alternate" type="application/atom+xml" href="https://aymengn.github.io/graphql/feed.xml" title="GraphQL - RSS"><link rel="alternate" type="application/json" href="https://aymengn.github.io/graphql/feed.json" title="GraphQL - JSON"><meta property="og:title" content="Understanding GraphQL Scalars and Enums"><meta property="og:site_name" content="GraphQL"><meta property="og:description" content="GraphQL is a powerful query language for APIs that allows clients to request exactly the data they need. One of its core features is its type system, which ensures that both the client and server have a clear understanding of the structure and shape of&hellip;"><meta property="og:url" content="https://aymengn.github.io/graphql/understanding-graphql-scalars-and-enums.html"><meta property="og:type" content="article"><link rel="preload" href="https://aymengn.github.io/graphql/assets/dynamic/fonts/robotoslab/robotoslab.woff2" as="font" type="font/woff2" crossorigin><link rel="stylesheet" href="https://aymengn.github.io/graphql/assets/css/style.css?v=11bee19e86e8eda2cf9a60efd975666d"><script type="application/ld+json">{"@context":"http://schema.org","@type":"Article","mainEntityOfPage":{"@type":"WebPage","@id":"https://aymengn.github.io/graphql/understanding-graphql-scalars-and-enums.html"},"headline":"Understanding GraphQL Scalars and Enums","datePublished":"2025-03-26T16:19+01:00","dateModified":"2025-03-26T16:42+01:00","description":"GraphQL is a powerful query language for APIs that allows clients to request exactly the data they need. One of its core features is its type system, which ensures that both the client and server have a clear understanding of the structure and shape of&hellip;","author":{"@type":"Person","name":"aymen gn","url":"https://aymengn.github.io/graphql/authors/aymen-gn/"},"publisher":{"@type":"Organization","name":"aymen gn"}}</script><noscript><style>img[loading] {
                    opacity: 1;
                }</style></noscript></head><body class="post-template"><header class="top js-header"><a class="logo" href="https://aymengn.github.io/graphql/">GraphQL</a></header><main class="post"><article class="content"><div class="hero hero--noimage"><header class="hero__content"><div class="wrapper"><h1>Understanding GraphQL Scalars and Enums</h1><div class="feed__meta content__meta"><a href="https://aymengn.github.io/graphql/authors/aymen-gn/" class="feed__author">aymen gn</a> <time datetime="2025-03-26T16:19" class="feed__date">March 26, 2025</time></div></div></header></div><div class="entry-wrapper content__entry"><p>GraphQL is a powerful query language for APIs that allows clients to request exactly the data they need. One of its core features is its type system, which ensures that both the client and server have a clear understanding of the structure and shape of the data being exchanged. Two fundamental building blocks of this type system are <strong>Scalars</strong> and <strong>Enums</strong>. In this blog post, we'll explore what these types are, how they work, and why they are essential in GraphQL.</p><p>---</p><h2>What Are Scalars?</h2><p>Scalars are the most basic units of data in GraphQL. They represent primitive values such as strings, numbers, or booleans. Unlike objects, scalars cannot be broken down into smaller parts. They are the "leaf nodes" of a GraphQL query, meaning they represent the final data points returned by the API.</p><h3>Built-in Scalars in GraphQL</h3><p>GraphQL comes with a set of predefined scalar types:</p><ol><li><strong><code>Int</code></strong>: A signed 32-bit integer.</li></ol><ol><li><strong><code>Float</code></strong>: A signed double-precision floating-point number.</li></ol><ol><li><strong><code>String</code></strong>: A sequence of UTF-8 characters.</li></ol><ol><li><strong><code>Boolean</code></strong>: <code>true</code> or <code>false</code>.</li></ol><ol><li><strong><code>ID</code></strong>: A unique identifier, often used to refetch an object or as a key in a cache.</li></ol><p>For example, consider a simple query to fetch a user's details:</p><pre><code>graphql
query {
  user(id: "1") {
    id
    name
    age
    isActive
  }
}</code></pre><p>Here:</p><ul><li><code>id</code> is of type <code>ID</code>.</li></ul><ul><li><code>name</code> is of type <code>String</code>.</li></ul><ul><li><code>age</code> is of type <code>Int</code>.</li></ul><ul><li><code>isActive</code> is of type <code>Boolean</code>.</li></ul><h3>Custom Scalars</h3><p>While the built-in scalars cover many common use cases, GraphQL allows you to define custom scalars to handle more specific data types. For instance, you might want to create a <code>Date</code> scalar to represent dates in a standardized format.</p><p>To define a custom scalar, you can declare it in your schema like this:</p><pre><code>graphql
scalar Date</code></pre><p>On the server side, you would then provide serialization and deserialization logic for the <code>Date</code> scalar. For example, you could serialize a JavaScript <code>Date</code> object into an ISO string (<code>YYYY-MM-DD</code>) and parse it back when needed.</p><p>Custom scalars are particularly useful for enforcing validation rules or handling complex data formats consistently across your API.</p><p>---</p><h2>What Are Enums?</h2><p>Enums (short for enumerations) are another type of scalar in GraphQL, but they differ from regular scalars because their values are restricted to a predefined set of options. Enums are useful for fields that can only take on a limited number of discrete values.</p><h3>Defining Enums in GraphQL</h3><p>To define an enum, you list all possible values in your schema. For example, suppose you're building an e-commerce API and want to track the status of an order. You could define an <code>OrderStatus</code> enum like this:</p><pre><code>graphql
enum OrderStatus {
  PENDING
  SHIPPED
  DELIVERED
  CANCELLED
}</code></pre><p>Now, any field of type <code>OrderStatus</code> can only have one of these four values. This ensures consistency and prevents invalid data from being sent or received.</p><h3>Using Enums in Queries</h3><p>Here’s an example of how you might use the <code>OrderStatus</code> enum in a query:</p><pre><code>graphql
query {
  orders(status: SHIPPED) {
    id
    status
    createdAt
  }
}</code></pre><p>In this query:</p><ul><li>The <code>status</code> argument is of type <code>OrderStatus</code>.</li></ul><ul><li>The server will only return orders whose status matches the value <code>SHIPPED</code>.</li></ul><p>Enums make your API more intuitive by clearly documenting the possible values for a field. They also reduce errors by restricting input to valid options.</p><p>---</p><h2>Why Use Scalars and Enums?</h2><h3>1. <strong>Strong Typing</strong></h3><p>Scalars and enums enforce strong typing, ensuring that both the client and server agree on the structure and constraints of the data. This reduces bugs and improves developer confidence.</p><h3>2. <strong>Validation</strong></h3><p>Custom scalars and enums allow you to validate data at the schema level. For example, a <code>PositiveInt</code> scalar could ensure that only positive integers are accepted, while an <code>OrderStatus</code> enum ensures that only valid statuses are used.</p><h3>3. <strong>Documentation</strong></h3><p>By defining scalars and enums in your schema, you automatically generate documentation for your API. Tools like GraphiQL or Apollo Studio can display these definitions, making it easier for developers to understand and use your API.</p><h3>4. <strong>Reusability</strong></h3><p>Once defined, scalars and enums can be reused across multiple types and queries. For example, if you define a <code>Currency</code> enum, you can use it for pricing, discounts, and other financial fields throughout your schema.</p><p>---</p><h2>Practical Example: Combining Scalars and Enums</h2><p>Let’s tie everything together with a practical example. Imagine you’re building a task management app. Your schema might look like this:</p><pre><code>graphql
scalar DateTime</code></pre><p>enum TaskPriority {</p><pre><code>
  LOW
  MEDIUM
  HIGH
}</code></pre><p>type Task {</p><pre><code>
  id: ID!
  title: String!
  description: String
  priority: TaskPriority!
  dueDate: DateTime
  isCompleted: Boolean!
}</code></pre><p>type Query {</p><pre><code>
  tasks(priority: TaskPriority): [Task!]!
}</code></pre><p>In this schema:</p><ul><li><code>DateTime</code> is a custom scalar for handling timestamps.</li></ul><ul><li><code>TaskPriority</code> is an enum that restricts the priority values to <code>LOW</code>, <code>MEDIUM</code>, or <code>HIGH</code>.</li></ul><ul><li>The <code>Task</code> type uses both scalars and enums to define its fields.</li></ul><p>A sample query might look like this:</p><pre><code>graphql
query {
  tasks(priority: HIGH) {
    id
    title
    priority
    dueDate
    isCompleted
  }
}</code></pre><p>This query fetches all high-priority tasks along with their details. The use of scalars and enums ensures that the data is well-structured, validated, and easy to understand.</p><p>---</p><h2>Conclusion</h2><p>Scalars and enums are foundational elements of GraphQL’s type system. Scalars represent primitive values, while enums restrict fields to a predefined set of options. Together, they enable strong typing, validation, and reusability, making your API more robust and developer-friendly.</p><p>By leveraging custom scalars and enums, you can tailor your GraphQL schema to fit the specific needs of your application. Whether you’re working with dates, currencies, statuses, or other specialized data, scalars and enums provide the tools you need to build a clean, consistent, and maintainable API.</p><p>So the next time you’re designing a GraphQL schema, don’t overlook the power of scalars and enums—they might just be the unsung heroes of your API!</p><p>---</p><p><a href="https://aymengn.github.io/graphql/graphql-directives-skip-and-include.html">What do you think about scalars and enums? H</a></p><p>GraphQL Directives: @skip and @includeave</p><p><a href="https://aymengn.github.io/graphql/building-a-graphql-api-with-nodejs-and-express.html">Building a GraphQL API with Node.js and Express you used them in your projects? Share your experiences in the comments below!</a></p><p><a href="https://aymengn.github.io/graphql/using-graphql-with-mongodb-and-mongoose.html">Using GraphQL with MongoDB and Mongoose</a></p><p><a href="https://aymengn.github.io/graphql/graphql-and-postgresql-integration.html">GraphQL and PostgreSQL Integration</a></p></div><footer class="content__footer"><div class="entry-wrapper"><p class="content__updated">[MISSING TRANSLATION] March 26, 2025</p><div class="content__actions"><div class="content__share"><button class="btn--icon content__share-button js-content__share-button"><svg width="20" height="20" aria-hidden="true"><use xlink:href="https://aymengn.github.io/graphql/assets/svg/svg-map.svg#share"></use></svg> <span>[MISSING TRANSLATION]</span></button><div class="content__share-popup js-content__share-popup"></div></div></div><div class="content__bio bio"><div><h3 class="h4 bio__name"><a href="https://aymengn.github.io/graphql/authors/aymen-gn/" rel="author">aymen gn</a></h3></div></div></div><nav class="content__nav"><div class="wrapper"><div class="content__nav-inner"><div class="content__nav-prev"><a href="https://aymengn.github.io/graphql/graphql-fragments-reusing-query-logic.html" class="content__nav-link" rel="prev"><div><span>[MISSING TRANSLATION]</span> GraphQL Fragments: Reusing Query Logic</div></a></div><div class="content__nav-next"><a href="https://aymengn.github.io/graphql/graphql-directives-skip-and-include.html" class="content__nav-link" rel="next"><div><span>[MISSING TRANSLATION]</span> GraphQL Directives: @skip and @include</div></a></div></div></div></nav></footer></article><div class="content__related related"><div class="wrapper"><h2 class="h4 related__title">[MISSING TRANSLATION]</h2><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://aymengn.github.io/graphql/authors/aymen-gn/" class="feed__author">aymen gn</a> <time datetime="2025-03-26T16:09" class="feed__date">March 26, 2025</time></div><h3 class="feed__title"><a href="https://aymengn.github.io/graphql/graphql-subscriptions-for-real-time-data.html">GraphQL Subscriptions for Real-Time Data</a></h3></header><p>In today’s fast-paced digital world, real-time data is becoming a cornerstone of modern applications. Whether it’s live chat apps, stock tickers, collaborative tools like Google Docs, or even social media feeds, users expect instant updates without needing to refresh their browsers. GraphQL, with its flexible&hellip;</p><a href="https://aymengn.github.io/graphql/graphql-subscriptions-for-real-time-data.html" class="readmore feed__readmore">[MISSING TRANSLATION]</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://aymengn.github.io/graphql/authors/aymen-gn/" class="feed__author">aymen gn</a> <time datetime="2025-03-26T16:02" class="feed__date">March 26, 2025</time></div><h3 class="feed__title"><a href="https://aymengn.github.io/graphql/graphql-playground-exploring-the-graphiql-interface.html">GraphQL Playground: Exploring the GraphiQL Interface</a></h3></header><p>GraphQL has revolutionized the way developers interact with APIs, offering a more efficient and flexible alternative to traditional REST APIs. One of the most powerful tools for working with GraphQL is GraphiQL, an in-browser IDE that allows developers to explore, query, and debug GraphQL APIs&hellip;</p><a href="https://aymengn.github.io/graphql/graphql-playground-exploring-the-graphiql-interface.html" class="readmore feed__readmore">[MISSING TRANSLATION]</a></div></article><article class="feed__item feed__item--centered"><div class="feed__content"><header><div class="feed__meta"><a href="https://aymengn.github.io/graphql/authors/aymen-gn/" class="feed__author">aymen gn</a> <time datetime="2025-03-26T15:54" class="feed__date">March 26, 2025</time></div><h3 class="feed__title"><a href="https://aymengn.github.io/graphql/introduction-to-graphql-schema-design.html">Introduction to GraphQL Schema Design</a></h3></header><p>GraphQL is a query language for APIs and a runtime for executing those queries by using a type system defined for your data. One of the most important aspects of building a GraphQL API is designing the schema, which serves as the contract between the&hellip;</p><a href="https://aymengn.github.io/graphql/introduction-to-graphql-schema-design.html" class="readmore feed__readmore">[MISSING TRANSLATION]</a></div></article></div></div></main><footer class="footer footer--glued"><div class="wrapper"><div class="footer__copyright"><p>Powered by Publii</p></div><button id="backToTop" class="footer__bttop" aria-label="[MISSING TRANSLATION]" title="[MISSING TRANSLATION]"><svg width="20" height="20"><use xlink:href="https://aymengn.github.io/graphql/assets/svg/svg-map.svg#toparrow"/></svg></button></div></footer><script defer="defer" src="https://aymengn.github.io/graphql/assets/js/scripts.min.js?v=700105c316933a8202041b6415abb233"></script><script>window.publiiThemeMenuConfig={mobileMenuMode:'sidebar',animationSpeed:300,submenuWidth: 'auto',doubleClickTime:500,mobileMenuExpandableSubmenus:true,relatedContainerForOverlayMenuSelector:'.top'};</script><script>var images = document.querySelectorAll('img[loading]');
        for (var i = 0; i < images.length; i++) {
            if (images[i].complete) {
                images[i].classList.add('is-loaded');
            } else {
                images[i].addEventListener('load', function () {
                    this.classList.add('is-loaded');
                }, false);
            }
        }</script></body></html>